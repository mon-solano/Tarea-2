{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducci\u00f3n","text":""},{"location":"#introduccion-al-problema","title":"Introducci\u00f3n al problema","text":"<p>En la presente tarea se implementa el m\u00e9todo de la Cuadratura Gaussiana basada en los polinomios de Legendre el cual  permite realizar aproximaciones bastante precisas de integrales definidas. </p> <p>A continuaci\u00f3n se utilizar\u00e1 el m\u00e9todo anteriormente mencionado para aproximar el c\u00e1lculo de la integral: </p> \\[ \\int_{1}^{3} (x^6 - x^2 \\sin(2x))  dx \\] <p>Adem\u00e1s de determinar el n\u00famero m\u00ednimo de puntos necesarios para obtener una aproximaci\u00f3n con un error menor a \\(10^{-12}\\) de orden de magnitud.   </p>"},{"location":"explanation/","title":"M\u00e9todo Num\u00e9rico","text":""},{"location":"explanation/#explicacion-del-metodo-cuadratura-gaussiana-con-polinomios-de-legendre","title":"Explicaci\u00f3n del M\u00e9todo - Cuadratura Gaussiana con Polinomios de Legendre","text":""},{"location":"explanation/#polinomios-de-legendre","title":"Polinomios de Legendre:","text":"<p>Un polinomio de Legendre es una soluci\u00f3n polin\u00f3mica a una ecuaci\u00f3n diferencial lineal de segundo orden (Ecuaci\u00f3n de Legendre). Los polinomios de Legendre \\(P_N(x)\\) forman un sistema de polinomios ortogonales en el intervalo \\([-1, 1]\\). </p> <p>Estos polinomios se definen recursivamente como:  \\begin{align} P_0(x) = 1 \\ P_1(x) = x \\end{align}</p> \\[\\begin{align} (N+1)P_{N+1}(x) = (2N+1)xP_N(x) - NP_{N-1}(x) \\end{align}\\] <p>O bien, de una forma altenativa, se puede utilizar la F\u00f3rmula de Rodrigues para definir esto polinomios como: </p> \\[\\begin{align} P_N(x) = \\frac{1}{2^N N!}\\frac{d^N}{dx^N}\\left[(x^2-1)^N\\right] \\end{align}\\]"},{"location":"explanation/#cuadratura-gaussiana","title":"Cuadratura Gaussiana","text":"<p>Las ra\u00edces de lo polinomios de Legendre brindan los puntos \u00f3ptimos para evaluar la funci\u00f3n, lo cual es fundamental para la implementaci\u00f3n del m\u00e9todo de la Cuadratura Gaussiana. </p> <p>La Cuadratura Gaussiana aproxima integrales mediante la forma: </p> \\[\\begin{align} \\int_a^b {\\rm{d}}x  f(x) \\approx \\sum_{k=1}^{N} w_k f(x_k) \\end{align}\\] <p>Donde \\(w_k\\) son los pesos (que es como decir de forma coloquial cual relevante es un punto en la suma) y \\(x_k\\) son los puntos de muestreo (es decir las \\(N\\) ra\u00edces del polinomio de Legendre)</p> <p>Los pesos se calculan de la forma:  \\begin{align} w_k = \\frac{2}{(1-x_k^2)\\left[P_N'(x_k)\\right]^2} \\end{align}</p> <p>Mientras que las ra\u00edces del Polinomio de Legendre se calculan de la siguiente manera: \\begin{align} P_N(x_k) = 0 \\quad \\text{para } k = 1, 2, \\ldots, N \\end{align}</p> <p>Este m\u00e9todo funciona de una forma muy precisa debido a que cada peso compensa la distribuci\u00f3n no uniforme de los puntos hallados; adem\u00e1s de que con \\(N\\) puntos se logran integrar de forma exacta polinomios de grado \\(2N-1\\). </p>"},{"location":"reference/","title":"Referencia","text":""},{"location":"reference/#cuadrature.Gaussxw","title":"<code>Gaussxw(N)</code>","text":"<p>Calcula puntos y pesos de la cuadratura:</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>N\u00famero de nodos.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(x, w) donde x son los puntos y w los pesos.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x, w = Gaussxw(3)\n&gt;&gt;&gt; len(x)\n3\n</code></pre> Source code in <code>cuadrature.py</code> <pre><code>def Gaussxw(N):\n\n    \"\"\"\n    Calcula puntos y pesos de la cuadratura:\n\n    Args:\n        N (int): N\u00famero de nodos.\n\n    Returns:\n        tuple: (x, w) donde x son los puntos y w los pesos.\n\n    Examples:\n        &gt;&gt;&gt; x, w = Gaussxw(3)\n        &gt;&gt;&gt; len(x)\n        3\n    \"\"\"\n    x,w = np.polynomial.legendre.leggauss(N)\n    return x,w \n</code></pre>"},{"location":"reference/#cuadrature.Gaussxw_ab","title":"<code>Gaussxw_ab(a, b, x, w)</code>","text":"<p>Transforma puntos y pesos de [-1,1] a [a,b].</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>L\u00edmite inferior del intervalo.</p> required <code>b</code> <code>float</code> <p>L\u00edmite superior del intervalo.</p> required <code>x</code> <code>ndarray</code> <p>Puntos en [-1,1].</p> required <code>w</code> <code>ndarray</code> <p>Pesos en [-1,1].</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>(x_ab, w_ab) nodos y pesos transformados al intervalo [a,b].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x, w = Gaussxw(3)\n&gt;&gt;&gt; x_ab, w_ab = Gaussxw_ab(1, 3, x, w)\n</code></pre> Source code in <code>cuadrature.py</code> <pre><code>def Gaussxw_ab (a,b,x,w):\n\n    \"\"\"\n    Transforma puntos y pesos de [-1,1] a [a,b].\n\n    Args:\n        a (float): L\u00edmite inferior del intervalo.\n        b (float): L\u00edmite superior del intervalo.\n        x (np.ndarray): Puntos en [-1,1].\n        w (np.ndarray): Pesos en [-1,1].\n\n    Returns:\n        tuple: (x_ab, w_ab) nodos y pesos transformados al intervalo [a,b].\n\n    Examples:\n        &gt;&gt;&gt; x, w = Gaussxw(3)\n        &gt;&gt;&gt; x_ab, w_ab = Gaussxw_ab(1, 3, x, w)\n    \"\"\"\n\n    return 0.5 * (b-a) * x + 0.5 * (b+a), 0.5 * (b-a) * w\n</code></pre>"},{"location":"reference/#cuadrature.Integrando","title":"<code>Integrando(x)</code>","text":"<p>Funci\u00f3n a integrar:</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float o np.ndarray</code> <p>Valor de x.</p> required <p>Returns:</p> Type Description <p>float o np.ndarray: Resultado de x6 - x2 * sin(2*x).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Integrando(1)\n0.081...\n&gt;&gt;&gt; Integrando(np.array([1,2]))\narray([0.081..., 58.909...])\n</code></pre> Source code in <code>cuadrature.py</code> <pre><code>def Integrando(x):\n\n    \"\"\"\n    Funci\u00f3n a integrar:\n\n    Args:\n        x (float o np.ndarray): Valor de x.\n\n    Returns:\n        float o np.ndarray: Resultado de x**6 - x**2 * sin(2*x).\n\n    Examples:\n        &gt;&gt;&gt; Integrando(1)\n        0.081...\n        &gt;&gt;&gt; Integrando(np.array([1,2]))\n        array([0.081..., 58.909...])\n    \"\"\"\n    return x**6 - (x**2 * np.sin(2*x))\n</code></pre>"},{"location":"tutorials/","title":"Tutorial","text":""},{"location":"tutorials/#tutorial-de-uso","title":"Tutorial de uso","text":"<p>A continuaci\u00f3n se presenta el c\u00f3digo para calcular la integral \u222b(x\u2076 - x\u00b2sen(2x)) dx desde 1 hasta 3 usando cuadratura Gaussiana.</p> <p>Primeramente se importa la biblioteca NumPy para realizar c\u00e1lculos y accesar a los polinomios de Legendre </p> <pre><code>import numpy as np\n</code></pre> <p>Luego, se define la funci\u00f3n a Integrar:</p> <pre><code>def Integrando(x):\n    return x**6 - (x**2 * np.sin(2*x))\n</code></pre>"},{"location":"tutorials/#ahora-se-obtienen-los-puntos-y-los-pesos-con","title":"Ahora se obtienen los puntos y los pesos con:","text":"<pre><code>def Gaussxw(N):\n    x,w = np.polynomial.legendre.leggauss(N)\n    return x,w \n</code></pre> <p>donde leggauss(N) devuelve los puntos y los pesos para la cuadratura </p>"},{"location":"tutorials/#luego-se-construye-la-funcion-para-escalar-al-intervalo-ab","title":"Luego se construye la funci\u00f3n para escalar al intervalo [a,b]","text":"<pre><code>def Gaussxw_ab (a,b,x,w):\n    return 0.5 * (b-a) * x + 0.5 * (b+a), 0.5 * (b-a) * w\n</code></pre>"},{"location":"tutorials/#seguidamente-se-calculan-los-puntos-y-pesos-con-diferentes-vlores-de-n","title":"Seguidamente se calculan los puntos y pesos con diferentes vLORES DE n","text":"<p>Esto se logra siguiendo la sintaxis </p> <pre><code>x_2, w_2 = Gaussxw(2)\nx_3, w_3 = Gaussxw(3)\n</code></pre> <p>Hasta que se crea haber encontrado un valor de convergencia exacto.</p>"},{"location":"tutorials/#ahora-se-escalan-los-puntos-y-pesos-en-el-intervalo-correspondiente","title":"Ahora se escalan los puntos y pesos en el intervalo correspondiente","text":"<pre><code>exc_x2, exc_w2 = Gaussxw_ab(1,3,x_2, w_2)\nexc_x3, exc_w3 = Gaussxw_ab(1,3,x_3, w_3)\n</code></pre>"},{"location":"tutorials/#finalmente-se-calculan-las-integrales-aproximadas","title":"Finalmente se calculan las integrales aproximadas:","text":"<pre><code>integ_2 = np.sum(exc_w2 * Intengrando(exc_x2))\ninteg_3 = np.sum(exc_w3 * Intengrando(exc_x3))\n</code></pre> <p>Para visualizarlas se invoca el print:</p> <pre><code>print(f\"N=2: Integral \u2248 {integ_2}\")\n</code></pre> <p>En este caso, se encontr\u00f3 que en N=9 se obtiene el valor exacto de esa integral el cual es: 317.34424667382643 Por lo que todo lo anteriormente definido se repiti\u00f3 9 veces para mostar el resultado correcto y los resultados anteriores. </p>"},{"location":"tutorials/#importante","title":"Importante:","text":"<p>Es posible reutilizar la estructura de este c\u00f3digo solamente cambiando la funci\u00f3n a integrar y los intervalos en donde ser\u00e1 evaluada. </p>"}]}